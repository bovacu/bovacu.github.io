<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Documentacion interna &mdash; GDE  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Typedef NodeID" href="../api/typedef_UI_8h_1a52def656a21c22f8e6592a9f04842b84.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> GDE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../api/library_root.html">Library API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Documentacion interna</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sistema-de-renderizado">Sistema de renderizado</a></li>
<li class="toctree-l2"><a class="reference internal" href="#texture">Texture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mipmap">Mipmap</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vertex-buffer">Vertex Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#renderizar-nuestro-primer-rectangulo-o-casi">Renderizar nuestro primer rectangulo, o casi</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shaders">Shaders</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vertex-shader">Vertex Shader</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fragment-shader">Fragment Shader</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compilacion-del-shader">Compilacion del shader</a></li>
<li class="toctree-l3"><a class="reference internal" href="#como-programar-los-shaders">Como programar los shaders</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#nuestro-primer-rectangulo-ahora-si">Nuestro primer rectangulo, ahora si</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sistema-de-coordenadas-opengl-vs-coordenadas-de-mundo">Sistema de coordenadas OpenGL vs Coordenadas de mundo</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aspect-ratio">Aspect Ratio</a></li>
<li class="toctree-l2"><a class="reference internal" href="#model-view-projection-matrix">Model View Projection Matrix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#model">Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#view">View</a></li>
<li class="toctree-l3"><a class="reference internal" href="#projection">Projection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ortografica">Ortografica</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#nuestro-primer-rectangulo-con-matriz-mvp-y-camara">Nuestro primer rectangulo con matriz MVP y camara</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sprite">Sprite</a></li>
<li class="toctree-l2"><a class="reference internal" href="#texture-atlas">Texture Atlas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sprite-batch">Sprite Batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="#texto">Texto</a></li>
<li class="toctree-l2"><a class="reference internal" href="#frame-buffer">Frame Buffer</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Documentacion interna</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/internalDocs/internalDocs.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="documentacion-interna">
<h1>Documentacion interna<a class="headerlink" href="#documentacion-interna" title="Permalink to this headline"></a></h1>
<section id="sistema-de-renderizado">
<h2>Sistema de renderizado<a class="headerlink" href="#sistema-de-renderizado" title="Permalink to this headline"></a></h2>
<p>El sistema de renderizado esta diseñado para agrupar el mayor número de vértices posible y así ejecutar el mínimo número de <span class="xref myst"><u>draw calls</u></span>*. A cada conjunto de vertices y otros datos que veremos más adelante se les denomina <span class="xref myst"><u>batch</u></span>.</p>
<p>El sistema de renderizado se basa, en su más alto nivel, en un sistema de capas. Podemos entender estas capas como escenas que podemos ir acumulando una encima de otra.</p>
<p>El la parte de mas bajo nivel, el sistema esta compuesto por texturas, shaders, sprite batch, fuentes de texto y el frame buffer. Estos conceptos luego se usan en clases de más alto nivel, como los sprites o los shapes y en manejadores, como el textureAtlasManager, el fontManager… Los veremos uno por uno.</p>
<p>Para el renderizado vamos a usar una libreria llamada OpenGL, que nos permite trabajar a bastante bajo nivel con la GPU y pintar cosas por pantalla. OpenGL, a muy grandes rasgos, es una maquina de estados que nos permite crear buffers, decirle que tipo de dato va en el buffer, llenar el buffer, usar el buffer y vaciar el buffer. Un buffer no es mas que una region de memoria en la que almacenar datos, referenciada a partir de un ID para luego poder acceder a ese mismo buffer.</p>
<a class="reference internal image-reference" href="file:///home/borja/Desktop/buffer.png"><img alt="buffer.png" src="file:///home/borja/Desktop/buffer.png" style="width: 621px;" /></a>
</section>
<section id="texture">
<h2>Texture<a class="headerlink" href="#texture" title="Permalink to this headline"></a></h2>
<p><strong>API</strong></p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Tipo</p></th>
<th class="head"><p>Metodo</p></th>
<th class="head"><p>Descripcion</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Construc</p></td>
<td><p>Texture(const char*)</p></td>
<td><p>carga una imagen con loadFromFile</p></td>
</tr>
<tr class="row-odd"><td><p>Construc</p></td>
<td><p>Texture(Texture*, IntRect)</p></td>
<td><p>carga una subtextura a partir de una textura ya existente</p></td>
</tr>
<tr class="row-even"><td><p>bool</p></td>
<td><p>loadFromFile(const char*)</p></td>
<td><p>carga una imagen almacenada en el pc</p></td>
</tr>
<tr class="row-odd"><td><p>bool</p></td>
<td><p>loadFromMemory(unsigned char*, int)</p></td>
<td><p>carga una imagen generada en tiempo de ejecucion</p></td>
</tr>
<tr class="row-even"><td><p>bool</p></td>
<td><p>loadTextTexture(int, int)</p></td>
<td><p>crea una textura de fuente de texto</p></td>
</tr>
<tr class="row-odd"><td><p>bool</p></td>
<td><p>loadTextSubTexture(Vec2I, Vec2I, unsigned char*)</p></td>
<td><p>crea subtexturas para un glyph</p></td>
</tr>
<tr class="row-even"><td><p>float</p></td>
<td><p>getKb()</p></td>
<td><p>devuelve lo que pesa la imagen</p></td>
</tr>
<tr class="row-odd"><td><p>IntRect</p></td>
<td><p>getRegion()</p></td>
<td><p>devuelve la region de imagen a renderizar</p></td>
</tr>
<tr class="row-even"><td><p>uint</p></td>
<td><p>getOpenGLTextureID()</p></td>
<td><p>devuleve el puntero de la imagen en la GPU</p></td>
</tr>
</tbody>
</table>
<p>La textura es el elemento basico para poder renderizar imágenes. Sin ella solo podemos renderizar formas geométricas de uno o varios colores en función del shader que usemos, pero para poder renderizar imágenes necesitamos de texturas.</p>
<p>Para crear la textura usamos una librería llamada stb_image, una libreria sencilla de usar que nos devuelve, de una ruta hacia una imagen, un array con todos los datos de todos los pixeles de la imagen (en formato <font color="orange">unsigned char</font>), además de otros valores interesantes como el ancho y alto, si usa RGB o RGBA…</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">stbi_set_flip_vertically_on_load</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">texturePixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stbi_load</span><span class="p">(</span><span class="n">_path</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">channels</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">GLenum</span><span class="w"> </span><span class="n">_internalFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">_dataFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">channels</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">_internalFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GL_RGBA8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_dataFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GL_RGBA</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">channels</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">_internalFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GL_RGB8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_dataFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG_E</span><span class="p">(</span><span class="s">&quot;Not supported format image&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Una vez que tenemos estos datos, pasamos a la parte interesante, que es subir los datos a la GPU a través de OpenGL.</p>
<p>Primero de todo tenemos que entender que OpenGL funciona como una máquina de estados, es decir, nosotros le vamos diciendo que debe hacer, pero las cosas no se ejecutan hasta el momento de dibujar en pantalla.</p>
<p>El proceso para crear una textura es el siguiente:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glCreateTextures</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">openGLTextureID</span><span class="p">);</span><span class="w"></span>

<span class="n">glTextureStorage2D</span><span class="p">(</span><span class="n">openGLTextureID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">internalFormat</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="n">glTextureParameteri</span><span class="p">(</span><span class="n">openGLTextureID</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINEAR</span><span class="p">);</span><span class="w"></span>
<span class="n">glTextureParameteri</span><span class="p">(</span><span class="n">openGLTextureID</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_NEAREST</span><span class="p">);</span><span class="w"></span>

<span class="n">glTextureParameteri</span><span class="p">(</span><span class="n">openGLTextureID</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span><span class="w"> </span><span class="n">GL_REPEAT</span><span class="p">);</span><span class="w"></span>
<span class="n">glTextureParameteri</span><span class="p">(</span><span class="n">openGLTextureID</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span><span class="w"> </span><span class="n">GL_REPEAT</span><span class="p">);</span><span class="w"></span>

<span class="n">glTextureSubImage2D</span><span class="p">(</span><span class="n">openGLTextureID</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">dataFormat</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">texturePixels</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Primero debemos indicarle a OpenGL que queremos crear una textura mediante <font color="orange">glCreateTextures</font>, lo que genera un buffer en la GPU para esta imagen. La variable openGLTextureID es la más importante de todas ya que contiene la referencia dentro de la GPU de donde se encuentra la textura almacenada y es la única forma que tenemos de localizarla para usarla y finalmente limpiarla de memoria.</p>
<blockquote>
<div><p>Nota: Una vez subida la imagen a la GPU, esta NO ES MODIFICABLE, tendríamos que volver a subirla a la GPU</p>
</div></blockquote>
<p>Después le indicamos el tipo de imágen que vamos a almacenar y qué puntero la contiene (en este caso openGLTextureID) y con los valores que hemos sacado gracias a stb_image. El 1 es para el numero de mipmaps.</p>
<hr class="docutils" />
<section id="mipmap">
<h3>Mipmap<a class="headerlink" href="#mipmap" title="Permalink to this headline"></a></h3>
<p>Cuando queremos renderizar una imagen, podemos hacerlo de 3 formas diferentes.</p>
<ol class="arabic simple">
<li><p>En su tamaño original</p></li>
<li><p>Maximificada</p></li>
<li><p>Minimizada</p></li>
</ol>
<p>Claro es que no renderizar una imagen en su tamaño original, hara que de una u otra forma, pierda calidad. Por ello aparecen los mipmaps. Un mipmap es una copia optimizada de la textura original en un tamaño diferente al original, de esta forma no tenemos que estar escalando las imagenes en tiempo de ejecución.</p>
<p><a class="reference internal" href="http://www.learnopengles.com/wordpress/wp-content/uploads/2012/02/android-mipmap.png"><img alt="" src="http://www.learnopengles.com/wordpress/wp-content/uploads/2012/02/android-mipmap.png" style="width: 108px;" /></a></p>
<p>En el caso de arriba, la imagen original es la segunda mayor y hemos creado varios mipmaps de la imagen original, para poder usarlas en tiempo de ejecución.</p>
<hr class="docutils" />
<p>Después de indicar el tipo de imagen que vamos a almacenar en GPU y de decirle la cantidad de mipmaps, los canales (RGB o RGBA en nuestro caso) y el tamaño de la imagen, le indicamos las funciones que aplicar a la hora de escalar la imagen ya sea a menor o a mayor. En nuestro caso usaremos <font color="orange">GL_LINEAR</font> y <font color="orange">GL_NEAREST</font>, aunque podriamos usar los dos iguales tanto para escalado hacia arriba como para abajo.</p>
<p>Wrap seria para repetir la imagen (estilo un tile map) en altura o en anchura y usamos el mismo valor para ambas.</p>
<p>Finalmente viene la parte mas interesante, que es la de subir los datos a la GPU. Lo hacemos con la función <font color="orange">glTextureSubImage2D</font>, cuyos parametros son</p>
<ol class="arabic simple">
<li><p>Puntero a la imagen en GPU (openGLTextureID)</p></li>
<li><p>Mipmap a usar (0, o sea el primero)</p></li>
<li><p>OffsetX, 0 si queremos que la imagen empiece en origen en X</p></li>
<li><p>OffsetY, 0 si queremos que la imagen empiece en origen en Y</p></li>
<li><p>Anchura de la imagen</p></li>
<li><p>Altura de la imagen</p></li>
<li><p>Formato usado</p></li>
<li><p>Tipo de dato en que se mandan los datos <font color="orange">GL_UNSIGNED_BYTE</font> o lo que es lo mismo <font color="orange">unsigned char</font></p></li>
<li><p>El array conteniendo todos los pixels de la imagen</p></li>
</ol>
<p>Con esto ya habriamos subido la imagen a la GPU y ya seria localizable.</p>
<p>Esta es la primera forma de crear una textura. Tenemos otras formas, como generar una textura en tiempo de ejecucción mediante <font color="orange">loadFromMemory</font> o mediante una imagen ya existente con <font color="orange">Texture(Texture*, IntRect)</font> que es el segundo constructor de esta clase. Su uso lo veremos cuando documentemos el <span class="xref myst"><u>Texture Atlas Manager</u></span>.</p>
<p>Finalmente para liberar la memoria de la textura y limpiar usamos:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">openGLTextureID</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Con 1 los niveles de mipmap y openGLTextureID el puntero al buffer de la GPU que contiene la textura.</p>
</section>
</section>
<section id="vertex-buffer">
<h2>Vertex Buffer<a class="headerlink" href="#vertex-buffer" title="Permalink to this headline"></a></h2>
<p>Este es uno de los buffers mas importantes e imprescindibles de todos, ya que es por donde vamos a enviar datos a la GPU para despues poder usarlos en los <span class="xref myst">Shaders</span> y asi poder pintar correctamente nuestras texturas por pantalla. Este tipo de buffer es un poco diferente del de la textura, ya que aqui podemos enviar tantos bloques de datos como queramos, pero tenemos que especificarle muy bien como, en que orden y cuantos datos le estamos mandando para que OpenGL sepa interpretarlos sin problema. Vamos con ello.</p>
<p>Lo primero de todo es generar el buffer en la GPU, y para generar un buffer de vertices tenemos la funcion:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>El primer parametro indica el numero de buffers que queremos crear y el segundo parametro es la referencia que OpenGL nos devuelve hacia dicho buffer, para que podamos acceder a el siempre que queramos.</p>
<p>Como ya sabemos, OpenGL es una maquina de estados, por lo que generar el buffer no implica que lo hayamos seleccionado para trabajar con el. Por ello para comunicarle a OpenGL que queremos trabajar con un buffer usamos:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vbo</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Con esta funcion OpenGL ya sabe que las proximas operaciones se ejecutaran sobre el buffer que acabamos de crear. <font color="orange">GL_ARRAY_BUFFER</font> quiere decir que los datos que vamos a mandarle a la GPU estan en formato de un array, es decir, todos los atributos que vamos a enviarle se los mandaremos embutidos en un mismo array.</p>
<p>Pero, que es eso de atributos y que tipo podemos mandar? Un atributo al final de cuentas es un bloque de informacion acerca de un vertice, vamos a ver un ejemplo.</p>
<p>Si queremos renderizar una imagen, es decir, un rectangulo, tenemos que decirle a la GPU como hacerlo exactamente y esto se hace mediante los atributos:</p>
<img alt="texture.png" src="file:///home/borja/Downloads/texture.png" />
<p>Tenemos la imagen de arriba, lo primero es identificar sus vertices, que son <span class="math notranslate nohighlight">\(v_0\)</span>, <span class="math notranslate nohighlight">\(v_1\)</span>, <span class="math notranslate nohighlight">\(v_2\)</span> y <span class="math notranslate nohighlight">\(v_3\)</span>. Cada uno de estos vertices va a tener unos atributos, que pueden ser, entre otros, las coordenadas que ocupan dentro de la pantalla (<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(z\)</span>), el color que va a tener el vertice (<span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(g\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(a\)</span>), las coordenadas de la textura (<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>)… Podriamos incluir mas si fuesen necesarios.</p>
<p>Las coordenadas son claras, pero veamos un dibujo rapido:</p>
<img alt="texture2.png" src="file:///home/borja/Downloads/texture2.png" />
<p>Como vemos las coordenadas simplemente nos indican donde esta cada vertice en el espacio, sencillo.</p>
<p>El color es algo mas complicado. Vamos a ver como funciona en un simple triangulo sin textura, un triangulo que solo tiene color de fondo. El formato de color en el motor es RGBA, es decir, Red-Green-Blue-Alpha y sus valores estan normalizados, es decir, [0, 1].</p>
<img alt="rbg1.png" src="file:///home/borja/Downloads/rbg1.png" />
<p>Este triangulo es verde y lo es porque hemos definido que <span class="math notranslate nohighlight">\(v_0\)</span>, <span class="math notranslate nohighlight">\(v_1\)</span> y <span class="math notranslate nohighlight">\(v_2\)</span> tengan como color (0, 1, 0, 1), es decir, color verde.</p>
<p>Si a cada vertice le damos un color diferente, lo que obtendremos son combinaciones de los colores de todos los vertices por el triangulo:</p>
<img alt="rgb2.png" src="file:///home/borja/Downloads/rgb2.png" />
<p>Si usamos una textura, para que tenga su color natural usaremos blanco en todos los vertices, es decir, (1, 1, 1, 1). Pero si queremos tintar la textura de algun color, pondremos los vertices del color que queramos tintar.</p>
<p>Finalmente vamos con las coordenadas de la textura. Estas coordenadas indican que cantidad de la textura vamos a dibujar. Funcionan de la siguiente manera:</p>
<img alt="uv1.png" src="file:///home/borja/Downloads/uv1.png" />
<p>Es decir, si a <span class="math notranslate nohighlight">\(v_0\)</span> le asignamos la coordenada de textura (0, 0), a <span class="math notranslate nohighlight">\(v_1\)</span> (1, 0), a <span class="math notranslate nohighlight">\(v_2\)</span> (1, 1) y a <span class="math notranslate nohighlight">\(v_3\)</span> (0, 1) renderizaremos la imagen entera. Si por ejemplo las coordenadas son <span class="math notranslate nohighlight">\(v_0\)</span> (0, 0), <span class="math notranslate nohighlight">\(v_1\)</span> (0.5, 0), <span class="math notranslate nohighlight">\(v_2\)</span> (0.5, 0.5) y <span class="math notranslate nohighlight">\(v_3\)</span> (0, 0.5) entonces solo se renderizara la parte marcada en amarillo en la imagen de abajo:</p>
<img alt="uv2.png" src="file:///home/borja/Downloads/uv2.png" />
<p>Vista la teoria, vamos a ver como hariamos esto con codigo. Ya hemos creado anteriormente el buffer y lo hemos asignado para trabajar con el, ahora vamos a indicarle los atributos que vamos a usar, para ello:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">OpenGLVertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="w"> </span><span class="n">texCoord</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">GLsizei</span><span class="w"> </span><span class="n">_structSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">OpenGLVertex</span><span class="p">);</span><span class="w"></span>

<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">_structSize</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">_structSize</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">_structSize</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>Muchas cosas nuevas, vamos una por una. Primero, lo mas normal es agrupar todos los atributos que vamos a enviar a la GPU en un struct, de esta forma es mas facil trabajar al crear los atributos de un vertice. En nuestro caso primero tenemos un vector de 3 coordenadas que es la posicion, otro de 4 que es el color y otro de 2 que son las coordenadas de la textura.</p>
<p>La funcion <font color="orange">glVertexAttribPointer</font> tiene muchos parametros:</p>
<ol class="arabic simple">
<li><p>Location en el Shader.</p></li>
<li><p>Numero de elementos que tiene el atributo (vec2 -&gt; 2, vec3 -&gt; 3, mat4 -&gt; 16…)</p></li>
<li><p>El tipo de valor que tiene cada elemento, en la mayoria de los casos son floats</p></li>
<li><p>Si esta o no normalizado, es decir, entre [0,1]</p></li>
<li><p>El tamaño de la estructura de datos</p></li>
<li><p>Offset desde el que empieza</p></li>
</ol>
<p>Creo que el valor mas complicado de entender es el sexto, vamos con ello. La disposicion en memoria de nuestra estructura de datos Vertex2dUvColor es la siguiente:</p>
<img alt="memory.png" src="file:///home/borja/Downloads/memory.png" />
<p>Como podemos ver, la posicion tiene 3 elementos de tipo float y con offset 0 bytes, es decir, el punto donde empiezan en memoria los datos de la posicion es 0, por eso:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">_structSize</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Tiene en el segundo parametro con 3, porque tiene 3 elementos, el tercer parametro es un float y el sexto es nullptr, o lo que es lo mismo, 0.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">_structSize</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>En su sexto parametro ponemos 4 * 3, ya que cada float ocupa 4 bytes y por ello la informacion del color empieza despues de los 3 primeros 4 bytes.</p>
<p>Lo mismo ocurre para el atributo de las coordenadas de la textura, solo que en este caso hay que sumar los 3 *  4bytes de la posicion + los 4 * 4bytes del color.</p>
<p>Con esto ya tendriamos nuestro buffer mas que listo. Por ultimo, tenemos que decirle a OpenGL que por el momento no vamos a usar mas este buffer y lo hacemos asi:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="renderizar-nuestro-primer-rectangulo-o-casi">
<h2>Renderizar nuestro primer rectangulo, o casi<a class="headerlink" href="#renderizar-nuestro-primer-rectangulo-o-casi" title="Permalink to this headline"></a></h2>
<p>Por el momento ya hemos generado un buffer para la textura, la hemos subido a la GPu, hemos creado el buffer para los vertices y ahora tenemos que rellenarlo para poder pintar la imagen por pantalla.</p>
<p>Lo cierto es que a la GPU no le gusta pintar rectangulos formas geometricas con mas vertices de forma directa, a la GPU le gusta dibujar trinagulos, y hay que reconocer que es muy buena haciendolo. Lo que quiero decir con esto es que la imagen que vimos en el apartado anterior, ahora la tendremos que dividir en dos triangulos que estaran pegados y que formaran la imagen final, por lo que tendriamos lo siguiente:</p>
<img alt="squareDivided.png" src="file:///home/borja/Downloads/squareDivided.png" />
<p>Asi quedarian los dos triangulos, T0 siendo el rojo con vertices <span class="math notranslate nohighlight">\(v_0\)</span>, <span class="math notranslate nohighlight">\(v_1\)</span>, <span class="math notranslate nohighlight">\(v_2\)</span> y el triangulo amarillo T1 con vertices <span class="math notranslate nohighlight">\(v_0\)</span>, <span class="math notranslate nohighlight">\(v_2\)</span> y <span class="math notranslate nohighlight">\(v_3\)</span>. Como veis, al estar pegados se renderizaran como un solo rectangulo, ahi esta el truco.</p>
<p>Vamos primero a dibujar un rectangulo sin textura, que es mas sencillo y luego dibujaremos un trinagulo con textura. Cuales son los pasos?</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">OpenGLVertex</span><span class="w"> </span><span class="n">_vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="c1">//        position          color       texture coords</span>
<span class="w">    </span><span class="p">{{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}},</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}},</span><span class="w"> </span><span class="c1">// T0</span>
<span class="w">    </span><span class="p">{{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}},</span><span class="w"></span>

<span class="w">    </span><span class="p">{{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}},</span><span class="w"></span>
<span class="w">    </span><span class="p">{{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}},</span><span class="w"> </span><span class="c1">// T1</span>
<span class="w">    </span><span class="p">{{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}}</span><span class="w">  </span>
<span class="p">};</span><span class="w"></span>


<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vbo</span><span class="p">);</span><span class="w"></span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">OpenGLVertex</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">6</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span><span class="w"></span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>


<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// position</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// color</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// textureCoords</span>

<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>

<span class="n">glDisableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">glDisableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">glDisableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Nuevamente, muchas cosas tenemos aqui. Vamos una por una. Lo primero es crear los vertices y como podemos ver creamos 6 de ellos, cada uno de los vertices de los dos triangulos T0, T1 con sus respectivos atributos posicion, color y coordenada de textura. Ahora mismo hemos puesto en todos que la coordenada de la textura sea (0, 0) y es porque ahora mismo no vamos a hacer uso de ese atributo, entonces podemos dejarlo en (0, 0) porque vamos a dibujar un rectangulo con color plano azul.</p>
<p>Lo siguiente es decir en que buffer de vertices (vertex buffer) vamos a meter esta informacion, y para ello hacemos el <font color="orange">bind</font>. Una vez “bindeado”, le indicamos el tamaño que va a ocupar y le decimos desde que punto del array debe de inicarse. El ultimo valor de la funcion es <font color="orange">GL_STATIC_DRAW</font>, de momento vamos a dejarlo asi y ya explicaremos mas adelante por que lo usamos. Otra opcion posible seria <font color="orange">GL_DYNAMIC_DRAW</font>, pero como digo, lo veremos mas adelante.</p>
<p>La siguiente parte tiene que ver con la activacion de atributos en el Shader, lo que veremos mas adelante, pero si que teneis que fijaros que los valores 0, 1, 2 se corresponden con la posicion, color y coordenada de textura que indicamos al generar el buffer cuando usamos <font color="orange">glVertexAttribPointer</font>.</p>
<p>Una vez hemos activado los atributos para el Shader, podemos dibujar de dos formas, con <font color="orange">glDrawArrays</font> y con <font color="orange">glDrawElements</font>. En nuestro caso y por no usar un index buffer, usamos <font color="orange">glDrawArrays</font>.</p>
<p>El primer parametro es como OpenGL debe dibujar los datos que le hemos pasado y tenemos varias formas:</p>
<p><code class="docutils literal notranslate"><span class="pre">GL_POINTS</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_LINE_STRIP</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_LINE_LOOP</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_LINES</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_LINE_STRIP_ADJACENCY</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_LINES_ADJACENCY</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_TRIANGLE_STRIP</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_TRIANGLE_FAN</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_TRIANGLES</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_TRIANGLE_STRIP_ADJACENCY</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_TRIANGLES_ADJACENCY</span></code> and <code class="docutils literal notranslate"><span class="pre">GL_PATCHES</span></code></p>
<p>Como nosotros queremos triangulos, usamos <font color="orange">GL_TRIANGLES</font>. El cero es para ver en que punto del array empezamos, entonces en 0 porque queremos renderizar todos los vertices y finalmente el numero de vertices que hay que renderizar.</p>
<p>Por ultimo, desactivamos las locations que habiamos activado anteriormente. Y con esto estamos listos ya para mostrar por pantalla el rectangulo? Pues no! Para poder renderizar por pantalla el rectangulo necesitamos usar lo que se llama un Shader, que lo veremos a continuacion.</p>
</section>
<section id="shaders">
<h2>Shaders<a class="headerlink" href="#shaders" title="Permalink to this headline"></a></h2>
<p>Con las versiones viejas de OpenGL y con la textura cargada ya podriamos empezar a renderizar nuestras texturas y rectangulos, pero las versiones viejas tienen ciertos problemas porque tienen un pipeline estatico, frente a las nuevas que tienen uno dinamico gracias a los shaders.</p>
<p>Un shader no es mas que un programa, es decir, es codigo y el lenguaje, en el caso de OpenGL es GLSL. Este codigo tiene la peculiaridad de que en vez de ejecutarse en la CPU como el codigo que habituamos a escribir, lo hace en la GPU, es decir, es una forma de programar nuestra GPU. Y para que exactamente queremos poder programar la GPU? Pues para indicarle a nuestro motor como y donde debe pintar las cosas en la pantalla.</p>
<p>Los shaders no son mi fuerte, ya que no se hacerlos muy complejos, pero si que se como funcionan y es lo que voy a explicar. Pera ello vamos por pasos mostrando primero la API del motor.</p>
<p><strong>API</strong></p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Tipo</p></th>
<th class="head"><p>Metodo</p></th>
<th class="head"><p>Descripcion</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Construc</p></td>
<td><p>Shader()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>uint</p></td>
<td><p>loadFromFiles(const std::string&amp;, const std::string)</p></td>
<td><p>carga un shader almacenado en un archivo</p></td>
</tr>
<tr class="row-even"><td><p>uint</p></td>
<td><p>loadFromString(const std::string&amp;, const std::string&amp;)</p></td>
<td><p>carga un shader escrito en un string</p></td>
</tr>
<tr class="row-odd"><td><p>uint</p></td>
<td><p>getShaderID()</p></td>
<td><p>devuelve el puntero al buffer donde esta almacenado el programa en la GPU</p></td>
</tr>
</tbody>
</table>
<p>Lo primero de todo, un shader esta formado por varios sub-fragmentos de codigo que se ocupan de una parte del renderizado diferente. Minimo necesita dos, el Vertex Shader y el Fragment Shader. Nos centraremos solo en estos dos ya que son los mas importantes y obligatorios. Cada shader se ejecuta un numero bastante alto de veces y son operaciones todo el rato iguales que pueden paralelizarser. La GPU es muy buena en ejecutar secuencias de instrucciones iguales seguidas, es por eso mismo que el renderizado se ejecuta en la GPU ya que tienen muchos cores y conseguien paralelizar muchos y ejecutarlos muy rapidamente.</p>
<section id="vertex-shader">
<h3>Vertex Shader<a class="headerlink" href="#vertex-shader" title="Permalink to this headline"></a></h3>
<p>El vertex shader es el encargado de indicarle a la GPU donde estan los vertices que se van a renderizar. Este shader se ejecuta tantas veces como vertices vayamos a renderizar, es decir, si tenemos un cuadrado, tendremos 4 o 6 vertices (dependiendo del tipo de renderizado implementado). Con este shader podemos pintar en pantalla nuestras imagenes tal cual las vemos en el visor de imagenes de nuestro ordenador o podemos hacer cosas mas interesantes y mover estos vertices segun nos interese para crear efectos, como este:</p>
<a class="reference internal image-reference" href="https://programmer.help/images/blog/47bcd8b5e523a438cad67a6bb0336f80.jpg"><img alt="" src="https://programmer.help/images/blog/47bcd8b5e523a438cad67a6bb0336f80.jpg" style="width: 240px;" /></a>
<p>La estructura del shader es similar al main.cpp de C++:</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 400 core</span><span class="w"></span>

<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">in_position</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">in_color</span><span class="p">;</span><span class="w"></span>

<span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in_color</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">in_position</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Lo importante es el valor que finalmente tenga la variable <font color="orange">gl_Position</font> ya que es la posicion final de cada uno de los vertices.</p>
<blockquote>
<div><p>Nota: gl_Position es un <font color="orange">vec4</font>. Veremos por que cuando expliquemos la Model View Projection Matrix.</p>
</div></blockquote>
<p>Este es un ejemplo muy basico para poder renderizar un rectangulo del color que nosotros queramos.</p>
</section>
<section id="fragment-shader">
<h3>Fragment Shader<a class="headerlink" href="#fragment-shader" title="Permalink to this headline"></a></h3>
<p>Esta parte del shader se encarga de decirle a la GPU como debe pintar todos y cada uno de los pixeles a dibujar en la pantalla. Como podreis imaginar, es un shader que debe ser eficiente, ya que puede llegar a ejecutase una cantidad ingente de veces. En una imagen 100x100px se esta ejecutando 10.000 veces.</p>
<p>Este shader permite desde el mas simple de los renderizados, como es pintar las imagenes con su color original, hasta hacer que esten en escala de grises o en negativo, generar un blur, pintarlas de un solo color, generar un delineado al rededor de la imagen, crear niebla, generar efecto Toon, efecto de pixel art, glow… Tiene mil aplicaciones.</p>
<p>El formato es igual que el del vertex shader, pero calculamos cosas distintas:</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 400 core</span><span class="w"></span>

<span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Nuevamente hay mil cosas que explicar y las veremos mas adelante. Lo importante de este shader es el valor final de <font color="orange">gl_FragColor</font> que es color final de cada pixel.</p>
</section>
<section id="compilacion-del-shader">
<h3>Compilacion del shader<a class="headerlink" href="#compilacion-del-shader" title="Permalink to this headline"></a></h3>
<p>Como hemos dicho, un shader es un programa, y si algo sabemos los programadores es que de una u otra forma, antes de ejecutar el codigo hay que comprobar la sintaxis  y compilar dicho codigo. Pues los shaders no son una excepcion y esto lo hacemos en tiempo de ejecucion. Para ello lo primero que hacemos es crear un buffer para el shader, despues indicarle el codigo asociado al buffer y compilarlo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">_shaderID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateShader</span><span class="p">(</span><span class="n">_shaderType</span><span class="p">);</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_shaderCodePointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_shaderCode</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span><span class="w"> </span><span class="c1">// Esto viene de un string</span>
<span class="kt">int</span><span class="w"> </span><span class="n">_shaderCodeLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">_shaderCode</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="n">glShaderSource</span><span class="p">(</span><span class="n">_shaderID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_shaderCodePointer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_shaderCodeLength</span><span class="p">);</span><span class="w"></span>
<span class="n">glCompileShader</span><span class="p">(</span><span class="n">_shaderID</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><font color="orange">_shaderType</font> puede tener varios valores, pero en nuestro caso sera o <font color="orange">GL_VERTEX_SHADER</font> o <font color="orange">GL_FRAGMENT_SHADER</font> en funcion de cual queramos compilar.</p>
<p>Una vez compilado, tenemos que ver si ha tenido exito o si ha dado algun problema:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GLint</span><span class="w"> </span><span class="n">_isCompiled</span><span class="p">;</span><span class="w"></span>
<span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">_shaderID</span><span class="p">,</span><span class="w"> </span><span class="n">GL_COMPILE_STATUS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_isCompiled</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">_isCompiled</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">_infolog</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">_shaderID</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">_infolog</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG_E</span><span class="p">(</span><span class="s">&quot;Shader compile failed with error: &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">_infolog</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">_shaderID</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">_shaderID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>Nota: <font color="orange">LOG_E</font> es una macro que usa el propio motor, se puede quitar sin problemas, es solo para sacar en rojo por pantalla que ha habido un error.</p>
</div></blockquote>
<p>Con <font color="orange">glGetShaderiv</font> comprobamos si el resultado esta compilado o no. En el caso de no ser compilado eliminamos el shader y devolvemos false para saber que hay error. Si no da error continuamos.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">_bufferShaderID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateProgram</span><span class="p">();</span><span class="w"></span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">_bufferShaderID</span><span class="p">,</span><span class="w"> </span><span class="n">_shaderID</span><span class="p">)</span><span class="w"></span>
<span class="n">glLinkProgram</span><span class="p">(</span><span class="n">_bufferShaderID</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Con estos ultimos pasos lo que hacemos primero es generar el buffer para el programa compilado final <font color="orange">_bufferShaderID</font>, despues le indicamos que a este puntero al buffer le corresponde el codigo compilado anteriormente en el buffer con ID <font color="orange">_shaderID</font> y finalmente el link junta todas las partes compiladas en un solo programa, el shader final.</p>
</section>
<section id="como-programar-los-shaders">
<h3>Como programar los shaders<a class="headerlink" href="#como-programar-los-shaders" title="Permalink to this headline"></a></h3>
<p>Lo primero es que cada shader debe programarse en un archivo en separado. Bueno, esto es mentira, pero en mi opinion es la forma mas ordenada de hacerlo. Con que al final tengas un string que contenga todo el codigo del vertex shader y otro con el del fragment es mas que suficiente, pero a mi me gusta separarlo en dos archivos.</p>
<p>Vamos a coger el codigo anterior del vertex shader y analizarlo:</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 400 core</span><span class="w"></span>

<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">in_position</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">in_color</span><span class="p">;</span><span class="w"></span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">in_uv</span><span class="p">;</span><span class="w"></span>

<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">dummyUniform</span><span class="p">;</span><span class="w"></span>

<span class="k">out</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span><span class="w"></span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">uv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in_uv</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in_color</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">in_position</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Lo primero es poner siempre la <font color="orange">#version</font> y es obligatorio y muy importante ya que no todas las versiones de GLSL soportan las mismas caracteristicas. En general, poniendo de la 400 para arriba, no deberiais tener problemas.</p>
<p>Despues vemos <font color="orange">layout</font>, <font color="orange">location</font>, <font color="orange">in</font>, <font color="orange">uniform</font>, <font color="orange">mat4</font>, varios <font color="orange">vec</font>, <font color="orange">out</font>… Vamos, un monton de palabras clave complicadas. Vamos de una en una.</p>
<p>Lo primero que tenemos que saber es que estas variables se pasan desde la CPU a la GPU, es decir, no obtienen sus valores magicamente, si no que primero se calculan en CPU y la GPU los usa. <font color="orange">layout</font>, <font color="orange">uniform</font> son las diferentes formas en que le podemos enviar datos desde la CPU a la GPU y como podreis imaginar, cada forma de envio es diferente. <font color="orange">in</font> remarca que es un valor de entrada para el shader.</p>
<p>El mas facil de todos es <font color="orange">uniform</font>. Este tipo de variable se envia en dos pasos mediante funciones de OpenGL:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GLint</span><span class="w"> </span><span class="n">_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">_bufferShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dummyUniform&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">_location</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Primero necesitamos obtener el <font color="orange">_location</font>, es decir, donde esta en el shader la variable llamada “dummyUniform”. Esta puede o no ser la mejor forma de hacerlo, ya que puede haber equivocaciones al escribir y el string debe coincidir con el nombre de la variable en el shader, pero es la que ofrece OpenGL, que yo sepa por lo menos.</p>
<p>Vale, tenemos que con la primera linea de codigo hemos descubierto donde se encuentra la variable, ahora podemos darle un valor. Para ello usamos la funcion</p>
<p><font color="orange">glUniform1f</font> que nos permite asignar como valor a la variable un float. Hay un monton de funciones diferentes dependiendo del tipo de variable que tenga el shader, aqui <a class="reference external" href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml">link</a>. Para todos los tipos de variables soportadas por GLSL aqui el [link](<a class="reference external" href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)">Data Type (GLSL) - OpenGL Wiki</a>).</p>
<p>Algo muy importante de las variables de tipo <font color="orange">uniform</font> es que tienen el mismo valor para todo el frame de renderizado.</p>
<p>La siguiente forma que usamos para enviar datos de la CPU al shader es mediante <font color="orange">layout</font> y <font color="orange">location</font>. Ahora es donde ponemos en practica lo aprendido en el apartado anterior donde primero usamos <font color="orange">glVertexAttribPointer</font> y luego <font color="orange">glEnableVertexAttribArray</font>. En cada uno de ellos el primer parametro era un <font color="orange">int</font> y como podeis ver, ese valor se corresponde con el <font color="orange">location</font>. En el <font color="orange">location</font> 0 del shader tenemos un <font color="orange">vec3</font> que es la posicion y con <font color="orange">glVertexAttribPointer</font> y <font color="orange">glEnableVertexAttribArray</font> le indicamos que en el valor 0 le enviaremos un <font color="orange">vec3</font> y asi sucesivamente con todos (excepto para el <font color="orange">vec2</font> de la coordenada de la textura que lo he quitado ahora para simplificar el ejemplo, lo pondremos de nuevo un poco mas adelante).</p>
<p>Las variables <font color="orange">out</font> son valores que van a pasar al siguiente shader de la cadena de shaders, en nuestro caso son valores que pasaran al Fragment Shader, es decir, vamos a pasar los valores de las coordenadas de la textura y del color al fragment shader, donde este shader los utilizara.</p>
<p>Vamos con el codigo del Fragment Shader:</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 400 core</span><span class="w"></span>

<span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span><span class="w"></span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Como vemos ahora tenemos <font color="orange">in</font> y no <font color="orange">out</font>. En este caso las variables <font color="magenta">uv</font> y <font color="magenta">color</font> reciben el valor <em>out</em> que tenian en el Vertex Shader. <font color="orange">gl_FragColor</font> es tambien un <font color="orange">vec4</font> y el color final que va a tener cada uno de los pixeles.</p>
<p>Con esto ya tenemos una nocion basica de como funciona un shader y como poder renderizar nuestro primer rectangulo.</p>
</section>
</section>
<section id="nuestro-primer-rectangulo-ahora-si">
<h2>Nuestro primer rectangulo, ahora si<a class="headerlink" href="#nuestro-primer-rectangulo-ahora-si" title="Permalink to this headline"></a></h2>
<p>En el motor usamos GLFW como libreria de manejo de la ventana, el codigo que se muestra ahora relacionado con GLFW no sera explicado hasta que lleguemos a la seccion donde expliquemos el sistema de ventana que usa el motor.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;GL/glew.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/mat4x4.hpp&gt;</span><span class="cp"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Vertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">_vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">{{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">                </span><span class="p">{{</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">                </span><span class="p">{{</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w"></span>

<span class="w">                </span><span class="p">{{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">                </span><span class="p">{{</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">                </span><span class="p">{{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_vertexShaderSrc</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;#version 400</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;uniform mat4 MVP;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;layout (location = 0) in vec3 vPos;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;layout (location = 1) in vec4 vCol;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;out vec4 color;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;void main()</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;{</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;    gl_Position = vec4(vPos, 1.0);</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;    color = vCol;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_fragmentShaderSrc</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;#version 400</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;in vec4 color;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;void main()</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;{</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;    gl_FragColor = color;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">key_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scancode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mods</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GLFW_KEY_ESCAPE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GLFW_PRESS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_TRUE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Saltar hasta la parte de glewInit</span>
<span class="w">    </span><span class="n">GLFWwindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">GLuint</span><span class="w"> </span><span class="n">_vertexBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">_vertexShader</span><span class="p">,</span><span class="w"> </span><span class="n">_fragmentShader</span><span class="p">,</span><span class="w"> </span><span class="n">_program</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">glfwInit</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Simple example&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">window</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">glfwTerminate</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwSetKeyCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">key_callback</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glfwSwapInterval</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Aqui ya hay que prestar atencion</span>
<span class="w">    </span><span class="n">glewInit</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertexBuffer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">_vertexBuffer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">_vertices</span><span class="p">),</span><span class="w"> </span><span class="n">_vertices</span><span class="p">,</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_vertexShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glShaderSource</span><span class="p">(</span><span class="n">_vertexShader</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertexShaderSrc</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glCompileShader</span><span class="p">(</span><span class="n">_vertexShader</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_fragmentShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_FRAGMENT_SHADER</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glShaderSource</span><span class="p">(</span><span class="n">_fragmentShader</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_fragmentShaderSrc</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glCompileShader</span><span class="p">(</span><span class="n">_fragmentShader</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateProgram</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">glAttachShader</span><span class="p">(</span><span class="n">_program</span><span class="p">,</span><span class="w"> </span><span class="n">_vertexShader</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glAttachShader</span><span class="p">(</span><span class="n">_program</span><span class="p">,</span><span class="w"> </span><span class="n">_fragmentShader</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glLinkProgram</span><span class="p">(</span><span class="n">_program</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">_vertexShader</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">_fragmentShader</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">_program</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Codigo aun no importante</span>
<span class="w">        </span><span class="n">glfwGetFramebufferSize</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Este si es importante</span>
<span class="w">        </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Lo mismo, aun nada</span>
<span class="w">        </span><span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glfwPollEvents</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Importante</span>
<span class="w">    </span><span class="n">glDeleteProgram</span><span class="p">(</span><span class="n">_program</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertexBuffer</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Aun no</span>
<span class="w">    </span><span class="n">glfwDestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glfwTerminate</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Como podeis ver, hay un moton de codigo aqui. Todo lo que tenga que ver con GLFW de momento lo pasamos. Sin contar eso, todo el codigo ya se ha explicado como funciona en los apartados anteriores, excepto glewInit(). Para usar OpenGL podemos usar varias librerias, como glad, pero en nuestro caso he decidido usar glew, por ninguna razon en particular, podeis usar glad si quereis. glewInit() inicia todo el sistema de OpenGL y debe ejecutarse antes de llamar a cualquier funcion de OpenGL. Devuelve un valor que si es distinto de 0, significa que hay un error, asi que tened cuidado con eso.</p>
<p>Ahora mismo hemos dibujado una imagen sin textura, dibujaremos una con textura un poco mas adelante.</p>
</section>
<section id="sistema-de-coordenadas-opengl-vs-coordenadas-de-mundo">
<h2>Sistema de coordenadas OpenGL vs Coordenadas de mundo<a class="headerlink" href="#sistema-de-coordenadas-opengl-vs-coordenadas-de-mundo" title="Permalink to this headline"></a></h2>
<p>Este tema en particular no se si todo el mundo lo aborda de la misma manera, pero voy a explicar como lo hago yo.</p>
<p>Como hemos visto en el ejemplo completo anterior, las posiciones de los vertices estaban siempre entre [-1, 1] tanto para x como para y, lo que indica que la posicion mas lejana a la izquierda renderizable es -1, a la derecha 1 (en el eje x esto es mentira, lo veremos en el siguiente apartado), arriba 1 y abajo -1. Como podreis imaginar no es especialmente amigable tener que decir que en pantalla nuestros objetos estan en (0.12, -0.53), si no que si nuestra ventana tiene una dimension de por ejemplo, 1280x720, nos gustaria poder dar las coordenadas entre los puntos [-640, 640] en el eje x y [-360, 360] en el eje y, algo mucho mas conveniente.</p>
<p>Bueno, el caso es que si se las damos asi directamente a OpenGL, no le gusta nada, ya que a el le gustan las coordenadas entre [-1, 1] (siempre que estemos dentro del espacio de la camara, y sin mover esta, lo veremos mas adelante, para nosotros ahora la camara es estatica y solo entran cosas entre [-1, 1]).</p>
<p>Muy bonita la explicacion, pero como hacemos esto? Pues facil, tenemos que normalizar el tipo de coordenadas que a nosotros nos interesa usar para que OpenGL pueda entenderlas, vamos con ello:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">windowWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1280</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">windowHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">720</span><span class="p">;</span><span class="w"></span>

<span class="kt">float</span><span class="w"> </span><span class="n">worldCoordX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">250</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">worldCoordY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-100</span><span class="p">;</span><span class="w"></span>

<span class="kt">float</span><span class="w"> </span><span class="n">openGLCoordX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worldCoordX</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">windowWidth</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.f</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">openGLCoordY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worldCoordY</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">windowHeight</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Y con esto ya estaria. Dividimos la altura y anchura entre 2 porque hay que dividir la pantalla en dos trozos iguales, uno positivo y otro negativo, tanto en x como en y.</p>
</section>
<section id="aspect-ratio">
<h2>Aspect Ratio<a class="headerlink" href="#aspect-ratio" title="Permalink to this headline"></a></h2>
<p>Aspect ratio es la relacion que hay entre la anchura y la altura de nuestra ventana, es decir:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">windowWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1280</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">windowHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">720</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">aspectRatio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">windowWidth</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">windowHeight</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Y de que nos sirver esto? Pues vamos con ello. Si ejecutamos de nuevo el codigo del ejemplo, veremos que las coordenadas deberian de generar un cuadrado, pero estan generando un rectangulo.</p>
<p>La razon es porque la pantalla que hemos creado no es cuadrada, al igual que practicamente ningun monitor de los que existen actualmente y aun no siendo cuadrada, le estamos diciendo que la distancia en el eje x [-1, 1] es la misma que la que hay en el eje y [-1, 1], cuando es mentira porque la anchura es mayor que la altura. El aspect ratio soluciona este problema, ya que la distancia real en x es [-aspectRatio, aspectRatio].</p>
<p>Esto nos hace tener que refactorizar el codigo del apartado anterior a lo siguiente:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">windowWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1280</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">windowHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">720</span><span class="p">;</span><span class="w"></span>

<span class="kt">float</span><span class="w"> </span><span class="n">worldCoordX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">250</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">worldCoordY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-100</span><span class="p">;</span><span class="w"></span>

<span class="kt">float</span><span class="w"> </span><span class="n">openGLCoordX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aspectRatio</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">worldCoordX</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">windowWidth</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.f</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">openGLCoordY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worldCoordY</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">windowHeight</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Ahora si tenemos las coordenadas correctas tanto en x como en y. Aunque aun no estamos 100% listos para poder representar bien nuestro cuadrado con su resolucion correcta, vamos con el siguiente punto.</p>
</section>
<section id="model-view-projection-matrix">
<h2>Model View Projection Matrix<a class="headerlink" href="#model-view-projection-matrix" title="Permalink to this headline"></a></h2>
<p>Este capitulo es intenso, ya que hay muchos conceptos matematicos. Soy ingeniero de software, no matematico, asi que es posible que algunos conceptos no los explique a la perfeccion, pero creo que es mas importante que entendais el concepto general y ya despues indagais por vuestra cuenta para entenderlo al detalle, asi que vamos con ello.</p>
<p>Cuando desarrollamos juegos, y otros motores conocidos como Unity o Godot, tenemos siempre el concepto de Transform, propiedad que contiene o que nos permite modificar la posicion, rotacion y escala de un objeto en la escena, pero que es exactamente este Transform? Pues es una matrix 4x4 y a fin de cuentas es la matriz Model.</p>
<section id="model">
<h3>Model<a class="headerlink" href="#model" title="Permalink to this headline"></a></h3>
<p>La matriz Model es la que nos indica la posicion, escala y rotacion de nuestros objetos en el espacio. Cuando vamos a calcular esta matriz, empezamos siempre con una matriz identidad 4x4:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
M = \begin{bmatrix}1 &amp; 0   &amp; 0   &amp; 0 
\\             0   &amp; 1 &amp; 0   &amp; 0
\\             0   &amp; 0   &amp; 1 &amp; 0
\\             0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\end{split}\]</div>
<p>Pero que significa esta matriz exactamente? Bueno, para un objeto en el espacio, la matriz identidad significa que su escala es 1 en todos los ejes, que su posicion es el origen (0, 0, 0) y que no tiene rotacion. Los tres primeros elementos de la diagonal (empezando por la esquina superior izquierda) representan la escala en x, y, z y los tres primeros elementos de la ultima columna nos indican la posicion en x, y, z. La rotacion va un poco por otro lado ya que es bastante mas compleja, pero obviando esa parte, podemos escribir de forma generica que una matriz Model es:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
M = \begin{bmatrix}s_x &amp; 0   &amp; 0   &amp; t_x 
\\             0   &amp; s_y &amp; 0   &amp; t_y
\\             0   &amp; 0   &amp; s_z &amp; t_z
\\             0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\end{split}\]</div>
<p>Con (<span class="math notranslate nohighlight">\(s_x, s_y, s_z\)</span>) la escala y pudiendo ser cualquier valor real y (<span class="math notranslate nohighlight">\(t_x, t_y, t_z\)</span>) lo mismo pero para la posicion.</p>
<p>Si queremos trasladar nuestro objeto a una nueva posicion, multiplicaremos <span class="math notranslate nohighlight">\(M * T\)</span>, siendo <span class="math notranslate nohighlight">\(M\)</span> actualmente la matriz identidad.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
T = \begin{bmatrix}1   &amp; 0   &amp; 0   &amp; t_x 
\\             0   &amp; 1   &amp; 0   &amp; t_y
\\             0   &amp; 0   &amp; 1   &amp; t_z
\\             0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\end{split}\]</div>
<p>Esto hara que nuestro objeto este en la nueva posicion (<span class="math notranslate nohighlight">\(t_x, t_y, t_z\)</span>).</p>
<p>Para escalar, multiplicamos <span class="math notranslate nohighlight">\(M * S\)</span> siendo <span class="math notranslate nohighlight">\(S\)</span> la matriz de escalado:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
M = \begin{bmatrix}s_x &amp; 0   &amp; 0   &amp; 0 
\\             0   &amp; s_y &amp; 0   &amp; 0
\\             0   &amp; 0   &amp; s_z &amp; 0
\\             0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\end{split}\]</div>
<p>Lo que escalara nuestro objeto al vector (<span class="math notranslate nohighlight">\(s_x, s_y, s_z\)</span>).</p>
<p>Finalmente, para rotar hay que elegir primero sobre que eje rotar, ya que un objeto podemos rotarlo en 3 ejes diferentes (x, y, z) o en una combinacion de los mismos:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
R_x = \begin{bmatrix}1   &amp; 0   &amp; 0   &amp; 0 
\\                   0   &amp; cos(α)   &amp; -sen(α)   &amp; 0
\\                   0   &amp; sen(α)   &amp; cos(α)   &amp; 0
\\                   0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
R_y = \begin{bmatrix}cos(α)   &amp; 0   &amp; sen(α)   &amp; 0 
\\                   0   &amp; 1   &amp; 0   &amp; 0
\\                   -sen(α)   &amp; 0   &amp; cos(α)   &amp; 0
\\                   0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
R_y = \begin{bmatrix}cos(α)   &amp; -sen(α)   &amp; 0   &amp; 0 
\\                   sen(α)   &amp; cos(α)   &amp; 0   &amp; 0
\\                   0   &amp; 0   &amp; 1   &amp; 0
\\                   0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\end{split}\]</div>
<p>Sabiendo ya las posibles transformaciones que puede tener un objeto, definimos la matriz Model como:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
M = I \\
M = T * R * S
\end{split}\]</div>
<p>Ahora me imagino que estareis algo asustados al pensar que hay que implementar todas estas matrices e implementar las operaciones etc… Bueno, el hecho es que si quereis, podeis hacerlo, pero hay librerias muy optimizadas que se encargan ya de ello, como es en este caso GLM, la libreria matematica de OpenGL. Esta libreria ya sabe generar matrices, vectores y realizar las operaciones directamente entre ellas.</p>
<p>Tenemos <font color="orange">vec2, vec3, vec4, mat2, mat3, mat4</font>, entre otros tipos de daots, pero estos seran los que mas vamos a utilizar de todos. Lo bueno es que podemos operar directamente con ellos, multiplicandolos, sumandoloes… GLM lo hace por nosotros.</p>
<p>Y para trasladar tenemos <font color="orange">glm::translate(mat4, vec3)</font>, para rotar <font color="orange">glm::rotate(mat4, float, vec3)</font> y para escalar <font color="orange">glm::scale(mat4, vec3)</font>. Veremos mas adelante como usar cada una de ellas.</p>
</section>
<section id="view">
<h3>View<a class="headerlink" href="#view" title="Permalink to this headline"></a></h3>
<p>La matriz View a mi me gusta llamarla la “matriz de lo que la camara nos muestra”, si, un nombre muy corto, pero que representa muy bien lo que hace. La matriz View representa donde esta la camara y que es lo que ve, pero al final no deja de ser como una matrix Model mas. Esta matriz no tiene ninguna formula chula como en el apartado anterior, es solo una matriz que representa el transform de la camara. En apartados posteriores veremos como hacer que la camara vea mas o menos cosas.</p>
</section>
<section id="projection">
<h3>Projection<a class="headerlink" href="#projection" title="Permalink to this headline"></a></h3>
<p>Ahora vamos a decidir como vamos a enfocar lo que se muestra en pantalla, y tenemos que decidir el tipo de vista que queremos, podemos elegir entre:</p>
<ul class="simple">
<li><p>Ortografica</p></li>
<li><p>Perspectiva</p></li>
</ul>
<p>Son dos tipos de vistas bastante diferentes, incluso a la hora de crearlas hay diferentes parametros. La principal diferencia es, que para mi, ortografica es mas para juegos 2D (aunque no exlusivamente) y la perspectiva es para juegos 3D, por que? Porque la proyeccion perspectiva nos permite hacer que los objetos mas lejanos se vean menores y los cercanos mayores, entre otras cosas. La siguiente imagen lo define muy bien:</p>
<section id="ortografica">
<h4>Ortografica<a class="headerlink" href="#ortografica" title="Permalink to this headline"></a></h4>
<p>En este tipo de camara hay que indicar lef, right, top, bottom, near y far. Left y right quiere decir la anchura que va a tener la camara [-aspectRatio, aspectRatio], top y bottom la altura que va a tener la camara [-1, 1] y near y far creo que lo mejor es entenderlo como un sandwich que esta de pie, far es la rebanada de atras y near la de delante [-1, 1] y solo se vera lo que esta dentro del sandwich. En 2D no debemos preocuparnos mucho por eso ya que todo esta en el mismo plano, es decir, no es un sandwich con varias capas de jamon, queso y lechuga, es solo el jamon.</p>
<p>Esta si que tiene una matriz de las chulas:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
O = \begin{bmatrix}\frac{2}{right - left} &amp; 0   &amp; 0   &amp; -\frac{right + left}{right - left} 
\\                 0   &amp; \frac{2}{top - bottom} &amp; 0   &amp; -\frac{top + bottom}{top - bottom}
\\                 0   &amp; 0   &amp; -\frac{2}{far - near} &amp; -\frac{far + near}{far - near}
\\                 0   &amp; 0   &amp; 0   &amp; 1
\end{bmatrix}
\end{split}\]</div>
<p>De nuevo, GLM viene al rescate y genera esta matriz por nosotrs mediante</p>
<p><font color="orange">glm::ortho(left, right, bottom, top, near, far)</font></p>
<p>Como nuestro modelo de motor es solo 2D y solo voy a usar la ortografica, no veremos la de perspectiva.</p>
<p>Finalmente, la matriz resultante de multiplicar todas las explicadas se denomina ModelViewProjection matrix, o MVP matrix, que ironicamente al calcularlo es custo al reves MVP = P * V * M.</p>
</section>
</section>
<section id="nuestro-primer-rectangulo-con-matriz-mvp-y-camara">
<h3>Nuestro primer rectangulo con matriz MVP y camara<a class="headerlink" href="#nuestro-primer-rectangulo-con-matriz-mvp-y-camara" title="Permalink to this headline"></a></h3>
<p>Bueno, hemos avanzado bastante y por fin vamos a poder renderizar nuestro cuadrado como un cuadrado de verdad y no como un rectangulo, vamos a aplicar todo lo que hemos aprendido.</p>
<blockquote>
<div><p>Nota: He sustituido el array de Vertex por un std::vector<Vertex>, para que sea mas sencilla la manipulacion, ademas de que cuando veamos el Sprite Batch tendra mas sentido tenerlo asi</p>
</div></blockquote>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;GL/glew.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/mat4x4.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/ext/matrix_clip_space.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/ext/matrix_transform.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/gtc/type_ptr.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;core/util/Logger.h&quot;</span><span class="cp"></span>

<span class="kt">float</span><span class="w"> </span><span class="n">aspectRatio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1280</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">720.f</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Vertex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_vertexShaderSrc</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;#version 400</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;uniform mat4 MVP;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;layout (location = 0) in vec3 vPos;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;layout (location = 1) in vec4 vCol;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;uniform mat4 viewProjection;&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;out vec4 color;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;void main()</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;{</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;    gl_Position = viewProjection * vec4(vPos, 1.0);</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;    color = vCol;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_fragmentShaderSrc</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;#version 400</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;in vec4 color;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;void main()</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;{</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;    gl_FragColor = color;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">key_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scancode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mods</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GLFW_KEY_ESCAPE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GLFW_PRESS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_TRUE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG_I</span><span class="p">(</span><span class="n">aspectRatio</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">GLFWwindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">GLuint</span><span class="w"> </span><span class="n">_vertexBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">_vertexShader</span><span class="p">,</span><span class="w"> </span><span class="n">_fragmentShader</span><span class="p">,</span><span class="w"> </span><span class="n">_program</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">GLint</span><span class="w"> </span><span class="n">mvp_location</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">glfwInit</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="w"> </span><span class="mi">720</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Simple example&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">window</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">glfwTerminate</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwSetKeyCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">key_callback</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glfwSwapInterval</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glewInit</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertexBuffer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">_vertexBuffer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_vertexShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glShaderSource</span><span class="p">(</span><span class="n">_vertexShader</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertexShaderSrc</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glCompileShader</span><span class="p">(</span><span class="n">_vertexShader</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_fragmentShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_FRAGMENT_SHADER</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glShaderSource</span><span class="p">(</span><span class="n">_fragmentShader</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_fragmentShaderSrc</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glCompileShader</span><span class="p">(</span><span class="n">_fragmentShader</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">_program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateProgram</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">glAttachShader</span><span class="p">(</span><span class="n">_program</span><span class="p">,</span><span class="w"> </span><span class="n">_vertexShader</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glAttachShader</span><span class="p">(</span><span class="n">_program</span><span class="p">,</span><span class="w"> </span><span class="n">_fragmentShader</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glLinkProgram</span><span class="p">(</span><span class="n">_program</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">_vertexShader</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">_fragmentShader</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">_program</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">_camara</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">ortho</span><span class="p">(</span><span class="o">-</span><span class="n">aspectRatio</span><span class="p">,</span><span class="w"> </span><span class="n">aspectRatio</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">})</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">0.f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">_camara</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_camara</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_view</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_vertex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">glfwGetFramebufferSize</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">_transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.f</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="w">        </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="w">        </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>

<span class="w">        </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="w">        </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="w">        </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>

<span class="w">        </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">_vertexBuffer</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_vertex</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">GLint</span><span class="w"> </span><span class="n">_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">_program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;viewProjection&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">_location</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">GLfloat</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">_camara</span><span class="p">)));</span><span class="w"></span>

<span class="w">        </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">_vertex</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>

<span class="w">        </span><span class="n">_vertex</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">glfwPollEvents</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>


<span class="w">    </span><span class="n">glDeleteProgram</span><span class="p">(</span><span class="n">_program</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertexBuffer</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwDestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwTerminate</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Genial! Tenemos nuestro primer cuadrado, pero algunos que os gusta toquetear mas de la cuenta habreis visto que cuando modificamos la dimension de la ventana, vuelve a ser un rectangulo. Vamos a arreglar esto colocando el codigo que voy a marcar con comentarios:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_vertex</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Esta variable es nueva</span>
<span class="kt">int</span><span class="w"> </span><span class="n">_currentWindowSize</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">glfwGetFramebufferSize</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Nuevo codigo</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">_currentWindowSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">||</span><span class="w">  </span><span class="n">height</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">_currentWindowSize</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_currentWindowSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">_currentWindowSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">_currentWindowSize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">_currentWindowSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="n">aspectRatio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">LOG_I</span><span class="p">(</span><span class="s">&quot;Aspect Ratio: &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">aspectRatio</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">_camara</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">ortho</span><span class="p">(</span><span class="o">-</span><span class="n">aspectRatio</span><span class="p">,</span><span class="w"> </span><span class="n">aspectRatio</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">_camara</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_camara</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_view</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Fin nuevo codigo</span>

<span class="w">    </span><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">_transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.f</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="w">    </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="w">    </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>

<span class="w">    </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="w">    </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="w">    </span><span class="n">_vertex</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">{</span><span class="n">_transform</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>

<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">_vertexBuffer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_vertex</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">GLint</span><span class="w"> </span><span class="n">_location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">_program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;viewProjection&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">_location</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">GLfloat</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">_camara</span><span class="p">)));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Este si es importante</span>
<span class="w">    </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">_vertex</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">_vertex</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Lo mismo, aun nada</span>
<span class="w">    </span><span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glfwPollEvents</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Como ya podreis ver, el problema es que al cambiar la altura o anchura de la ventana, la nueva dimension no se corresponde con el viejo aspect ratio, por lo que la camara esta mal calculada, asi que solo hay que volver a recalcularlo.</p>
</section>
</section>
<section id="sprite">
<h2>Sprite<a class="headerlink" href="#sprite" title="Permalink to this headline"></a></h2>
<p>Bueno hasta ahora solo hemos pintado un cuadrado, cada vez un poquito mas preciso y mejor, pero un simple cuadrado. Esto ya empieza a ser aburrido, vamos a pintar imagenes por pantalla, no?</p>
<p>Bueno, podriamos pintar directamente una Texture en la ventana, pero es un poco engorroso cuando tienes que pintar muchas por como se tienen que inicializar y los datos que hay que pasarles, por lo que vamos a utilizar las clases que ya existen en el motor, al fin y al cabo este es un documento para entender como funciona el motor.</p>
<p>Pero antes de nada, que es un Sprite? Bueno, es muy sencillo, un Sprite es un contenedor de datos, que en este caso contiene un Transform, que como ya hemos visto en el apartado de Model View Projection Matrix es una matriz en la que podemos almacenar y modificar la posicion y escala del objeto. Contiene tambien la rotacion que debe aplicarsele, y esto dentro del struct Transform, que se encuentra en core/systems/Components.h. Sprite tambien contiene un struct de SpriteRenderer (se encuentra en el mismo fichero que Transform) que a su vez contiene una referencia a la Texture que se quiere renderizar, contiene el ID del shader que se debe utilizar para renderizar dicha textura, contiene el color con el que el Fragment Shader debe pintar los pixeles de la textura (blanco por defecto) y contiene la capa en la que se debe renderizar, esto nos genera el efecto de profundidad, poder renderizar unas imagenes por encima de otras como nosotros queramos.</p>
<p>La clase Texture se puede encontrar en core/render/elements/Texture.h y su correspondiente cpp. En esta clase no hay mucho que explicar, todo se explico en el apartado de Texturas.</p>
<p>La clase Sprite esta en core/render/elements/Sprite.h y su cpp. Ya hemos explicado lo que es un Sprite, y basicamente los metodos que contiene son o bien para inicializarlo o bien para obetener o modificar sus propiedades.</p>
</section>
<section id="texture-atlas">
<h2>Texture Atlas<a class="headerlink" href="#texture-atlas" title="Permalink to this headline"></a></h2>
</section>
<section id="sprite-batch">
<h2>Sprite Batch<a class="headerlink" href="#sprite-batch" title="Permalink to this headline"></a></h2>
</section>
<section id="texto">
<h2>Texto<a class="headerlink" href="#texto" title="Permalink to this headline"></a></h2>
</section>
<section id="frame-buffer">
<h2>Frame Buffer<a class="headerlink" href="#frame-buffer" title="Permalink to this headline"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../api/typedef_UI_8h_1a52def656a21c22f8e6592a9f04842b84.html" class="btn btn-neutral float-left" title="Typedef NodeID" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Borja Vazquez Cuesta.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>