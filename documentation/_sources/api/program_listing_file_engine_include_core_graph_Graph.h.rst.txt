
.. _program_listing_file_engine_include_core_graph_Graph.h:

Program Listing for File Graph.h
================================

|exhale_lsh| :ref:`Return to documentation for file <file_engine_include_core_graph_Graph.h>` (``engine/include/core/graph/Graph.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // Created by borja on 9/3/22.
   
   
   #ifndef ENGINE_GRAPH_H
   #define ENGINE_GRAPH_H
   
   #include "entt/entt.hpp"
   #include "core/util/Delta.h"
   #include "core/systems/eventSystem/Event.h"
   #include "core/render/elements/Texture.h"
   
   namespace GDE {
   
       typedef entt::entity NodeID;
       typedef entt::registry NodeContainer;
       #define NODE_ID_NULL entt::null
   
       class Engine; class Scene;
       class Graph {
   
           friend class Scene;
   
           private:
               NodeID sceneRoot;
   
               std::string name;
   
               NodeContainer registry;
   
               Scene* scene = nullptr;
   
           private:
               void printScene(const NodeID&, std::ostream& _os, int& _indent);
   
               void remove(const NodeID& _node, bool _delete);
   
               void onEvent(Event& _event);
   
               void onUpdate(Delta _dt);
   
               void onFixedUpdate(Delta _dt);
   
               void onRender();
   
               void onDebugRender();
   
           public:
               UDelegate<void(NodeContainer&, Event&)> onEventDel;
   
               UDelegate<void(NodeContainer&, Delta)> onUpdateDel;
   
               UDelegate<void(NodeContainer&, Delta)> onFixedUpdateDel;
   
               UDelegate<void(NodeContainer&)> onRenderDel;
   
           public:
               Graph(Scene* _scene, const std::string& _sceneName);
               ~Graph() {};
   
               NodeID createNode(const std::string& _tag = "", const NodeID& _parent = NODE_ID_NULL);
   
               NodeID instantiatePrefab(const NodeID& _prefab, const Vec2F& _position, const NodeID& _parent = NODE_ID_NULL);
   
               void removeNode(const NodeID& _node);
   
               void removeNode(const std::string& _nodeTagName);
   
               void orphan(const NodeID& _node);
   
               void orphan(const std::string& _nodeTagName);
   
               NodeID getNode(const std::string& _tagName);
   
               void setParent(const NodeID& _node, const NodeID& _parent);
   
               template<typename Component, typename... Args>
               Component* addComponent(Args... _args);
   
               template<typename Component>
               void removeComponent(const NodeID& _id);
   
               template<typename Component>
               Component* getComponent(const NodeID& _id);
   
               template<typename Component>
               bool hasComponent(const NodeID& _id);
   
               std::string toString();
   
               NodeID getID();
   
               void setNodeStatic(NodeID _node, bool _static);
   
               bool isNodeStatic(NodeID _node);
   
               void setNodeActive(NodeID _node, bool _active);
   
               bool isNodeActive(NodeID _node);
   
               template<typename... Archetype>
               auto query();
   
               NodeContainer& getNodeContainer();
       };
   
       template <int I, class... Ts>
       decltype(auto) get(Ts&&... ts) {
           return std::get<I>(std::forward_as_tuple(ts...));
       }
   
   
       template<typename Component, typename... Args>
       Component* Graph::addComponent(Args... _args) {
           auto& first = get<0>(std::forward<Args>(_args)...);
           return &registry.template emplace<Component>(first, _args...);
       }
   
       template<typename Component>
       void Graph::removeComponent(const NodeID& _id) {
           registry.template remove<Component>(_id);
       }
   
       template<typename Component>
       Component* Graph::getComponent(const NodeID& _id) {
           return &registry.template get<Component>(_id);
       }
   
       template<typename... Archetype>
       auto Graph::query() {
           return registry.template view<Archetype...>().each();
       }
   
       template<typename Component>
       bool Graph::hasComponent(const NodeID& _id) {
           return registry.template any_of<Component>(_id);
       }
   }
   
   #endif //ENGINE_GRAPH_H
